

	# Code generated by Shell::POSIX::Select v0.05, by tim(AT)TeachMePerl.com
	# NOTA BENE: Line 1 of this segment must start with {, so user can LABEL it
  { # **** NEW WRAPPER SCOPE FOR SELECTLOOP #1 ****
		$Shell::POSIX::Select::DEBUG > 1 and 1 == 1 and
			warn "LINE NUMBER FOR START OF USER CODE_BLOCK IS:  ", __LINE__, "\n";
    _SEL_LOOP1: { # **** NEW SCOPE FOR SELECTLOOP #1 ****
	
		# critical for values's contents to be resolved in user's scope
		local @Shell::POSIX::Select::looplist=defined  ((( caller 0 )[3]) and  (( caller 0 )[3])  ne "") ? @_ : @ARGV ;
		local $Shell::POSIX::Select::num_values=@Shell::POSIX::Select::looplist;

		$Shell::POSIX::Select::DEBUG > 4 and do {
			warn "ARRAY VALUES ARE: @Shell::POSIX::Select::looplist\n";
			warn "NUM VALUES is $Shell::POSIX::Select::num_values\n"; 
			warn "user-program debug level is $Shell::POSIX::Select::U_WARN\n"; 
		};
		local $_;  # LOOP-VAR DECLARATION REQUESTED (perhaps by default)	# loop-var declaration appears here
	
    ;
    local (
			$Shell::POSIX::Select::Prompt[1],
			$Shell::POSIX::Select::menu
				) =
      Shell::POSIX::Select::make_menu(
				$Shell::POSIX::Select::Heading || "",
				$Shell::POSIX::Select::Prompt || "" ,	# Might be overridden in make_menu
				@Shell::POSIX::Select::looplist
			);

	 # no point in prompting a pipe!
		local $Shell::POSIX::Select::do_prompt[1] = (-t) ?  1 : 0 ;
		0 > 2 and warn "do_prompt is $Shell::POSIX::Select::do_prompt[1]\n";
    if ( defined $Shell::POSIX::Select::menu ) {             # No list, no iterations!
      while (1) {    # for repeating prompt for selections
		 # localize, so I don't have to reset  for
		 # outer loop on exit from inner
		 local ($Reply);
        while (1) {    # for validating user's input
          local $Shell::POSIX::Select::bad = 0;

          # local decl suppresses newline on prompt when -l switch turned on
          {
            local $\;
            if ($Shell::POSIX::Select::do_prompt[1]) {

							# When transferring from INNER to OUTER loop,
							# extra NL before prompt is visually desirable

							if ( $Shell::POSIX::Select::_extra_nl) {
								print STDERR "\n\n";
								$Shell::POSIX::Select::_extra_nl=0;
							}
							print STDERR
								"$Shell::POSIX::Select::menu\n$Shell::POSIX::Select::Prompt[1] ";
						}
          }

          #	$Shell::POSIX::Select::do_prompt=0;
					# constant prompting depends on style
          $Shell::POSIX::Select::do_prompt[1]= 0;

          if ( $Shell::POSIX::Select::dump_data ) {
						$Reply = undef;
						# dump filtered source for comparison against expected
						print STDERR "copacetic
";	# ensure some output, and flush pending
						exit 222;	# code for graceful, expected, early exit
					}
          else {
						# $^W=0;
						# warn "Waiting for input";
							$Eof=0;
							$Reply = <STDIN>;
						# warn "Got input";
						# $^W=1;

            if ( !defined( $Reply ) ) {
              defined "" and "" ne "" and print STDERR "";

              # need to undef loop var; user may check it!
              undef $_;

              # last Shell::POSIX::Select::_SEL_LOOP1;	# Syntax error!
              # If returning to outer loop, show the prompt for it
              # warn "User hit ^D";
              if ( 1 > 1 and -t ) {    # reset prompting for outer loop
                    $Shell::POSIX::Select::do_prompt[1-1] = 1; $Shell::POSIX::Select::_extra_nl=1;
              }
							0 > 2 and warn "Lasting out of _SEL_LOOP1\n";
							$Eof=1;
              last _SEL_LOOP1;
            }
						!defined $Reply and die "REPLY accessed, while undefined";
            chomp $Reply;

            # undo emboldening of user input
            defined "" and "" ne "" and print STDERR "";

            #print STDERR "$Shell::POSIX::Select::menu\n$Shell::POSIX::Select::Prompt ";
            if ( $Reply eq "" ) {    # interpreted as re-print menu request
                  # Empty input is legit, means redisplay menu
              $Shell::POSIX::Select::U_WARN > 1 and warn "\tINPUT IS: empty\n";
              $Shell::POSIX::Select::bad = $Shell::POSIX::Select::do_prompt[1] = 1;
            }
            elsif ( $Reply =~ /\D/ ) {    # shouldn't be any non-digit!
              $Shell::POSIX::Select::U_WARN > 0
                and warn "\tINPUT CONTAINS NON-DIGIT: '$Reply'\n";
              $Shell::POSIX::Select::bad = 1;    # Korn and Bash shell just ignore this case
            }
            elsif ( $Reply < 1 or $Reply > $Shell::POSIX::Select::num_values ) {
              $Shell::POSIX::Select::U_WARN > 0
                and warn
                "\t'$Reply' IS NOT IN RANGE: 1 - $Shell::POSIX::Select::num_values\n";
              $Shell::POSIX::Select::bad = 1;    # Korn and Bash shell just ignore this case
            }

            # warn "BAD is now: $Shell::POSIX::Select::bad";
             $Shell::POSIX::Select::bad or
							 0 > 2 and warn "About to last out of Reply Validator Loop
";
            $Shell::POSIX::Select::bad or last;    # REPLY VALIDATOR EXITED HERE
          }    # if for validating user input
        }    # infinite while for validating user input

        $_ = $Shell::POSIX::Select::looplist[$Reply - 1];    # set users' variable

        # USER'S LOOP-BLOCK BELOW
        
			print "$_\n" ; # ** USING DEFAULT CODEBLOCK **
		;

        # USER'S LOOP-BLOCK ABOVE
        # Making sure there's colon (maybe
        # even two) after codestring above,
        # in case user omitted after last
        # statement in block. I might add
        # another statement below it someday!
			 0 > 2 and warn "At end of prompt-repeating loop 
";
      }    # infinite while for repeating collection of selections
			0 and warn "BEYOND end of prompt-repeating loop 
";
    }    # endif (defined $Shell::POSIX::Select::menu)
    else {
      $Shell::POSIX::Select::DEBUG > 0 and warn "Shell::POSIX::Select: Select Loop #1 has no list, so no iterations\n";

				if ( $Shell::POSIX::Select::dump_data ) {
					$Reply = undef;
					# dump filtered source for comparison against expected
					print STDERR "copacetic
";	# ensure some output, and flush pending
					exit 222;	# code for graceful, expected, early exit
				}
    }
	# return omitted above, to get last expression's value
	# returned automatically, just like shell's version 

	
	  } # **** END NEW SCOPE FOR SELECTLOOP #1 ****
	} # **** END WRAPPER SCOPE FOR SELECTLOOP #1 ****
	# vi:ts=2 sw=2:
	
